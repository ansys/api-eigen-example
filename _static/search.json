[{"objectID":"Home","href":"api/python-rest/index.html#python-rest-subpackage","title":"Python REST subpackage","text":"Python REST subpackage\n\nThe Python REST subpackage contains the needed elements for client-server interaction using REST.\n\n"},{"objectID":"Home","href":"api/cpp-grpc/service.html#c-rest-service-module","title":"C++ REST service module","text":"C++ REST service module\n\n\n\nnamespace service\n\nNamespace including the API Eigen Example Server logic (i.e. service) implemented in C++. \n\n\n\nclass GRPCService : public grpcdemo::GRPCDemo::Service\n\nClass containing the server logic (i.e. service). \n\nPublic Functions\n\n\n\nGRPCService(const bool debug_log)\n\nConstruct a new GRPCDemo Service object. \n\nParameters\n\ndebug_log – whether to show the enhanced debugging logs or not. \n\n\n\n~GRPCService()\n\nDestroy the GRPCDemo Service object. \n\n\n\n::grpc::Status SayHello(::grpc::ServerContext *context, const ::grpcdemo::HelloRequest *request, ::grpcdemo::HelloReply *response) override\n\nMethod to provide a simple greeting to the client. \n\nParameters\n\ncontext – the gRPC Server context. \n\nrequest – the gRPC request. \n\nresponse – the gRPC response this method will fill. \n\nReturns\n\n::grpc::Status \n\n\n\n::grpc::Status FlipVector(::grpc::ServerContext *context, ::grpc::ServerReaderWriter<::grpcdemo::Vector, ::grpcdemo::Vector> *stream) override\n\nMethod to provide a flipped vector to the client. \n\nParameters\n\ncontext – the gRPC Server context. \n\nstream – the gRPC stream. \n\nReturns\n\n::grpc::Status \n\n\n\n::grpc::Status AddVectors(::grpc::ServerContext *context, ::grpc::ServerReaderWriter<::grpcdemo::Vector, ::grpcdemo::Vector> *stream) override\n\nMethod to provide the addition of Vector messages. \n\nParameters\n\ncontext – the gRPC Server context. \n\nstream – the gRPC stream. \n\nReturns\n\n::grpc::Status \n\n\n\n::grpc::Status MultiplyVectors(::grpc::ServerContext *context, ::grpc::ServerReaderWriter<::grpcdemo::Vector, ::grpcdemo::Vector> *stream) override\n\nMethod to provide the dot product of Vector messages. \n\nParameters\n\ncontext – the gRPC Server context. \n\nstream – the gRPC stream. \n\nReturns\n\n::grpc::Status \n\n\n\n::grpc::Status AddMatrices(::grpc::ServerContext *context, ::grpc::ServerReaderWriter<::grpcdemo::Matrix, ::grpcdemo::Matrix> *stream) override\n\nMethod to provide the addition of Matrix messages. \n\nParameters\n\ncontext – the gRPC Server context. \n\nstream – the gRPC stream. \n\nReturns\n\n::grpc::Status \n\n\n\n::grpc::Status MultiplyMatrices(::grpc::ServerContext *context, ::grpc::ServerReaderWriter<::grpcdemo::Matrix, ::grpcdemo::Matrix> *stream) override\n\nMethod to provide the multiplication of Matrix messages. \n\nParameters\n\ncontext – the gRPC Server context. \n\nstream – the gRPC stream. \n\nReturns\n\n::grpc::Status \n\nPrivate Functions\n\n\n\nEigen::VectorXd deserialize_vector(const std::string &bytes, const int length, grpcdemo::DataType type)\n\nMethod used to deserialize a Vector message into an Eigen::VectorXd object. \n\nParameters\n\nbytes – the chunk of bytes from where the vector is deserialized. \n\nlength – the length of the vector we are deserializing. \n\ntype – the type of data inside the vector (e.g. double, int…). \n\nReturns\n\nEigen::VectorXd \n\n\n\nstd::string serialize_vector(const Eigen::VectorXd &vector, const int start, const int end)\n\nMethod used to serialize an Eigen::VectorXd object into a Vector message. \n\nParameters\n\nvector – the Eigen::VectorXd to be serialized. \n\nstart – the starting index to serialize. \n\nend – the last index to serialize (not included). \n\nReturns\n\nstd::string \n\n\n\nEigen::MatrixXd deserialize_matrix(const std::string &bytes, const int rows, const int cols, grpcdemo::DataType type)\n\nMethod used to deserialize a Matrix message into an Eigen::MatrixXd object. \n\nParameters\n\nbytes – the chunk of bytes from where the matrix is deserialized. \n\nrows – the number of rows of the matrix we are deserializing. \n\ncols – the number of columns of the matrix we are deserializing. \n\ntype – the type of data inside the matrix (e.g. double, int…). \n\nReturns\n\nEigen::MatrixXd \n\n\n\nstd::string serialize_matrix(const Eigen::MatrixXd &matrix, const int start, const int end)\n\nMethod used to serialize an Eigen::MatrixXd object into a Matrix message. \n\nParameters\n\nmatrix – the Eigen::MatrixXd to be serialized. \n\nstart – the starting index to serialize. \n\nend – the last index to serialize (not included). \n\nReturns\n\nstd::string \n\n\n\nstd::vector<Eigen::VectorXd> receive_vectors(::grpc::ServerReaderWriter<grpcdemo::Vector, grpcdemo::Vector> *reader_writer, ::grpc::ServerContext *context)\n\nMethod in charge of providing a set of Eigen::VectorXd objects from a stream of Vector messages. \n\nParameters\n\nreader_writer – the gRPC reader-writer in the bidirectional stream protocol. \n\ncontext – the gRPC context. \n\nReturns\n\nstd::vector<Eigen::VectorXd> \n\n\n\nstd::vector<Eigen::MatrixXd> receive_matrices(::grpc::ServerReaderWriter<grpcdemo::Matrix, grpcdemo::Matrix> *reader_writer, ::grpc::ServerContext *context)\n\nMethod in charge of providing a set of Eigen::MatrixXd objects from a stream of Matrix messages. \n\nParameters\n\nreader_writer – the gRPC reader-writer in the bidirectional stream protocol. \n\ncontext – the gRPC context. \n\nReturns\n\nstd::vector<Eigen::MatrixXd> \n\n\n\nvoid send_vector(::grpc::ServerReaderWriter<grpcdemo::Vector, grpcdemo::Vector> *reader_writer, ::grpc::ServerContext *context, const Eigen::VectorXd &vector)\n\nMethod in charge of sending the resulting vector of the operation through the protocol. \n\nParameters\n\nreader_writer – the gRPC reader-writer in the bidirectional stream protocol. \n\ncontext – the gRPC context. \n\nvector – the vector to be sent. \n\n\n\nvoid send_matrix(::grpc::ServerReaderWriter<grpcdemo::Matrix, grpcdemo::Matrix> *reader_writer, ::grpc::ServerContext *context, const Eigen::MatrixXd &matrix)\n\nMethod in charge of sending the resulting matrix of the operation through the protocol. \n\nParameters\n\nreader_writer – the gRPC reader-writer in the bidirectional stream protocol. \n\ncontext – the gRPC context. \n\nmatrix – the matrix to be sent. \n\nPrivate Members\n\n\n\nbool _debug_log\n\nBoolean indicating whether to show the debugging logs or not. "},{"objectID":"Home","href":"api/python-grpc/index.html#python-grpc-subpackage","title":"Python gRPC subpackage","text":"Python gRPC subpackage\n\nThe Python gRPC subpackage contains the needed elements for client-server interaction using gRPC.\n\n"},{"objectID":"Home","href":"api/cpp-rest/server.html#c-rest-server-module","title":"C++ REST server module","text":"C++ REST server module\n\n\n\nnamespace server\n\nNamespace including the API Eigen Example Server implemented in C++. \n\n\n\nclass RestServer\n\nClass containing the server logic. \n\nPublic Functions\n\n\n\nRestServer()\n\nConstruct a new Rest Server object. \n\n\n\n~RestServer()\n\nDestroy the Rest Server object. \n\n\n\nvoid serve(const int port = 18080, const bool async = false, const crow::LogLevel logLevel = crow::LogLevel::Info)\n\nMethod for serving our application. \n\nParameters\n\nport – the port in which we want to server our app. Default: 18080. \n\nasync – whether we want to run application asynchronously or not. Default: false. \n\nlogLevel – the logging level of our server. Default: Info. \n\n\n\ninline crow::SimpleApp &get_app()\n\nGet the app object. \n\nReturns\n\ncrow::SimpleApp& \n\nPrivate Functions\n\n\n\nvoid vector_resource_endpoints()\n\nMethod defining the “Vectors” Resource endpoints. \n\n\n\nvoid matrix_resource_endpoints()\n\nMethod defining the “Matrices” Resource endpoints. \n\n\n\nvoid vector_operations_endpoints()\n\nMethod defining the “Vectors” operations endpoints. \n\n\n\nvoid matrix_operations_endpoints()\n\nMethod defining the “Matrices” operations endpoints. \n\n\n\ncrow::response add_vectors(int id1, int id2)\n\nMethod in charge of retrieving the Vector resources from the DB and adding them. \n\nParameters\n\nid1 – - the id of the first Vector. \n\nid2 – - the id of the second Vector. \n\nReturns\n\ncrow::response \n\n\n\ncrow::response multiply_vectors(int id1, int id2)\n\nMethod in charge of retrieving the Vector resources from the DB and performing their dot product. \n\nParameters\n\nid1 – - the id of the first Vector. \n\nid2 – - the id of the second Vector. \n\nReturns\n\ncrow::response \n\n\n\ncrow::response add_matrices(int id1, int id2)\n\nMethod in charge of retrieving the Matrix resources from the DB and adding them. \n\nParameters\n\nid1 – - the id of the first Matrix. \n\nid2 – - the id of the second Matrix. \n\nReturns\n\ncrow::response \n\n\n\ncrow::response multiply_matrices(int id1, int id2)\n\nMethod in charge of retrieving the Matrix resources from the DB and multiplying them. \n\nParameters\n\nid1 – - the id of the first Matrix. \n\nid2 – - the id of the second Matrix. \n\nReturns\n\ncrow::response \n\nPrivate Members\n\n\n\ndb::RestDb _db\n\nThe server’s DB. \n\n\n\ncrow::SimpleApp _app\n\nThe server CROW application. "},{"objectID":"Home","href":"api/cpp-grpc/index.html#c-grpc-subpackage","title":"C++ gRPC subpackage","text":"C++ gRPC subpackage\n\nThe C++ gRPC subpackage contains the needed elements for client-server interaction using gRPC.\n\n"},{"objectID":"Computation times","href":"sg_execution_times.html#computation-times","title":"Computation times","text":"Computation times\n\n00:00.089 total execution time for 2 files from all galleries:\n\n\n\n\n\n\n\nExample\n\nTime\n\nMem (MB)\n\nsphx_glr_examples_00-rest-examples_python_rest_demo.py (../../examples/00-rest-examples/python_rest_demo.py)\n\n00:00.067\n\n0.0\n\nsphx_glr_examples_01-grpc-examples_python_grpc_demo.py (../../examples/01-grpc-examples/python_grpc_demo.py)\n\n00:00.022\n\n0.0"},{"objectID":"Home","href":"examples/00-rest-examples/index.html#api-eigen-example---rest-demo","title":"API Eigen Example - REST Demo","text":"API Eigen Example - REST Demo\n\nThese examples demonstrate full examples of API REST interaction between a server and a client.\n\nsphx_glr_examples_00-rest-examples_python_rest_demo.py\n\n"},{"objectID":"Home","href":"api/python-rest/server.html#python-rest-server-module","title":"Python REST server module","text":"Python REST server module\n\n\n\nPython implementation of the REST API Eigen example server.\n\n\n\nansys.eigen.python.rest.server.create_app()\n\nInitialize the REST API server.\n\nReturns\n\nFlask\n\nInstance of the application.\n\nRaises\n\nInvalidUsage\n\nIn case no JSON-format request body was provided.\n\nInvalidUsage\n\nIn case no ‘value’ is provided within the request body.\n\nInvalidUsage\n\nIn case the given argument is not a string.\n\nInvalidUsage\n\nIn case the given type is not in the ALLOWED_TYPES tuple."},{"objectID":"Home","href":"users_guide/index.html#users-guide","title":"User’s guide","text":"User’s guide\n\nThis guide describes how to use the API Eigen Example package and its modules\nand components."},{"objectID":"Home","href":"users_guide/index.html#understanding-the-api-eigen-example-python-module","title":"User’s guide > Understanding the API Eigen Example Python module","text":"Understanding the API Eigen Example Python module\n\nThe``ansys.eigen.python`` package contains the necessary objects for testing the API REST\nand gRPC communication protocols, which are implemented in Python. It also includes two\nadditional Python packages:\n\nREST package: ansys.eigen.python.rest\n\ngRPC package: ansys.eigen.python.grpc\n\nEach of these packages contains two key modules for performing the demos: client\nand server. This section is divided into REST and gRPC package subsections."},{"objectID":"Home","href":"users_guide/index.html#the-api-rest-eigen-example-python-module","title":"User’s guide > The API REST Eigen Example Python module","text":"The API REST Eigen Example Python module\n\nImport the API REST Python server and client with:\n\nThe API REST Python server is a Flask app that contains a SQLite database (DB). You can easily\ndeploy this server by running commands in the terminal. If you are located at the root directory\nof the repository, you can deploy this version of the server with:\n\nWhile the preceding commands deploy the server with default parameters, you can deploy it manually by\ncalling the create_app() method to return the Flask app and then run it using the app.run()\nmethod:\n\nThe Python client contains a class called DemoRESTClient that provides tools for interacting\ndirectly with the deployed server. For example, to create an API REST client for interacting with\nthe previously deployed server, you would run:\n\nThe client is then made available to perform operations such as:"},{"objectID":"Home","href":"users_guide/index.html#the-api-grpc-eigen-example-python-module","title":"User’s guide > The API gRPC Eigen Example Python module","text":"The API gRPC Eigen Example Python module\n\nImport the API gRPC Python server and client with:\n\nThe API gRPC Python server is a standalone gRPC app with no DB. You can easily deploy this server\nby running commands in the terminal. If you are located at the root directory of the repository, you\ncan deploy this version of the server with:\n\nWhile the preceding command deploys the server with default parameters, you can deploy it manually by\ncalling the serve() method inside the module:\n\nThe Python client contains a class called DemoGRPCClient that provides tools for interacting\ndirectly with the deployed server. For example, to create an API gRPC client for interacting with\nthe previously deployed server, you would run:\n\nThe client is then made available to perform operations such as:"},{"objectID":"Home","href":"users_guide/index.html#understanding-the-api-eigen-example-c-module","title":"User’s guide > Understanding the API Eigen Example C++ module","text":"Understanding the API Eigen Example C++ module\n\nThe``ansys.eigen.python`` package also includes two C++ projects, which are C++ implementations of the\npreviously explained Python packages:\n\nC++ REST projects: src/ansys/eigen/cpp/rest\n\nC++ gRPC projects: src/ansys/eigen/cpp/grpc\n\nEach of these C++ packages contains two key modules for performing the demos: client and server.\nThis section is divided into REST and gRPC project subsections."},{"objectID":"Home","href":"users_guide/index.html#the-api-rest-eigen-example-c-projects","title":"User’s guide > The API REST Eigen Example C++ projects","text":"The API REST Eigen Example C++ projects\n\nFirst you must install the projects as per the instructions in getting_started.\n\nOnce projects are installed, run these include commands:\n\nThe API REST C++ server is a CrowCpp app that contains a SQLite DB. You can easily deploy this server by running\ncommands in the terminal.\n\nIf you create a simple server.cpp file, you can do the following:\n\nOnce the library is installed, you can compile the server.cpp file:\n\nYou can then run the executable that results from the compilation:\n\nYou see these messages as your server is being deployed:\n\nWhile the preceding command deploys the server with default parameters, you can deploy it with your own custom\nparameters by providing optional inputs in the serve() method.\n\nThe C++ client contains a class called EigenClient that provides tools for interacting\ndirectly with the deployed server. For example, to create an API REST client for interacting with\nthe previously deployed server, you could write the following code snippet in a new C++ file (for example, client.cpp)\nand then call it:\n\nThe client then deals with a vector addition operation via REST API interaction\nwith the server, apart from requesting a greeting.\n\nYou compile the client with:\n\nYou then run the executable that results from the compilation:\n\nEnjoy creating your own apps."},{"objectID":"Home","href":"users_guide/index.html#the-api-grpc-eigen-example-c-projects","title":"User’s guide > The API gRPC Eigen Example C++ projects","text":"The API gRPC Eigen Example C++ projects\n\nFirst you must install the projects as per the instructions in getting_started.\n\nOnce projects are installed, run these include commands:\n\nThe API gRPC C++ server is a standalone gRPC app. You can easily deploy this server by running\ncommands in the terminal.\n\nIf you create a simple server.cpp file, you can do the following:\n\nOnce the library is installed, you can compile the server.cpp file:\n\nYou then run the executable that results from the compilation:\n\nYou see these messages as your server is being deployed:\n\nWhile the preceding command deploys the server with default parameters, you can deploy it with your own custom\nparameters by providing optional inputs in the serve() method.\n\nThe C++ client contains a class called GRPCClient that provides tools for interacting\ndirectly with the server. For example, if you wanted to create an API gRPC client for interacting with\nthe previously deployed server, you would write the following code snippet in a new C++ file (for example, client.cpp)\nand then call it:\n\nThe client then deals with a vector addition operation via gRPC API interaction\nwith the server, apart from requesting a greeting.\n\nYou compile the client app with:\n\nYou then run the executable that results from the recompilation:\n\nYou see these messages as your server is being deployed:\n\nOn the server side, you see these logs:\n\nEnjoy creating your own apps."},{"objectID":"Home","href":"index.html#api-eigen-example-documentation-001","title":"API Eigen Example Documentation 0.0.1","text":"API Eigen Example Documentation 0.0.1\n\n"},{"objectID":"Home","href":"index.html#introduction","title":"API Eigen Example Documentation 0.0.1 > Introduction","text":"Introduction\n\nThe API Eigen Example package is a simple demo project for showing PyAnsys users and developers the\ndifferences between the API REST communication protocol and the gRPC communication protocol, which is\nused extensively in PyAnsys libraries.\n\nThe main goal of this demo project is to expose the Eigen library\nto end users via a client-server interaction that can be implemented using API REST or gRPC communication protocols.\n\nThe server exposes certain functionalities of the Eigen library, such as adding and\nmultiplying Eigen::VectorXd and Eigen::MatrixXd objects. The computational operations are\nperformed in the Eigen Library installed within the server, and the results are returned to the\nend user (or client). Thus, it is not necessary for the client to have the Eigen library installed.\n\nThe client is intended to aid end users because it provides them with tools for communicating with the server\nwithout needing to know the specifics of the protocol implemented. However, you can use CURL commands to interact\ndirectly with the server via API REST communication.\n\nThis demo project contains four different examples:\n\nA Python REST API demo using both client-server features, which has\na wrapping over the Eigen library using pybind11.\n\nA Python gRPC API demo using both client-server features, which\nhas a wrapping over the Eigen library using pybind11.\n\nA C++ REST API demo using both client-server features,\nwith direct interaction with the Eigen Library on the server side.\n\nA C++ gRPC API demo using both client-server features, with\ndirect interaction with the Eigen Library on the server side."},{"objectID":"Home","href":"index.html#features","title":"API Eigen Example Documentation 0.0.1 > Features","text":"Features\n\nThis demo package provides these primary features:\n\nA client providing end users with the ability to perform server-side operations\nwithout knowing details on the communication protocol being employed\n\nCore examples on how to expose a service (that is, the Eigen Library) via a server using\ndifferent communication protocols.\n\nBenchmark tests showing the performance of each of the client-server and programming\nlanguage implementations."},{"objectID":"Home","href":"index.html#project-index","title":"API Eigen Example Documentation 0.0.1 > Project index","text":"Project index\n\ngenindex"},{"objectID":"Home","href":"examples/01-grpc-examples/sg_execution_times.html#computation-times","title":"Computation times","text":"Computation times\n\n00:00.022 total execution time for 1 file from examples/01-grpc-examples:\n\n\n\n\n\n\n\nExample\n\nTime\n\nMem (MB)\n\nsphx_glr_examples_01-grpc-examples_python_grpc_demo.py (python_grpc_demo.py)\n\n00:00.022\n\n0.0"},{"objectID":"Home","href":"getting_started/index.html#getting-started","title":"Getting started","text":"Getting started\n\nThe API Eigen example package is a simple project for showing PyAnsys\nusers and developers the differences between the API REST communication protocol\nand the gRPC communication protocol that is used extensively in PyAnsys libraries.\n\nThis project has multiple language implementations."},{"objectID":"Home","href":"getting_started/index.html#api-eigen-example-python-project","title":"Getting started > API Eigen Example Python project","text":"API Eigen Example Python project\n\nTo use the API Eigen Example project in its Python version, you do not need any specific requirements or\nadditional software, apart from the ones that are installed via the requirements --all-files\nand a CMake version of the Eigen library."},{"objectID":"Home","href":"getting_started/index.html#installation","title":"Getting started > Installation","text":"Installation\n\nFirst install the Eigen library (and CMake if it is not present). For Ubuntu distributions, it is as\neasy as running:\n\nTo install a local version of the API Eigen Example project, clone the repository\nthrough the Ansys GitHub Enterprise account:\n\nIf you want to use Python versions of the API Eigen Example project, install the\ndemo-eigen-wrapper, which is a wrapper to the Eigen library that uses pybind11:\n\nFinally, install the project with:"},{"objectID":"Home","href":"getting_started/index.html#starting-to-use-the-project","title":"Getting started > Starting to use the project","text":"Starting to use the project\n\nOnce the API Eigen Example project has been installed, start to make use of the Python\npackages by importing them:\n\nFor more examples, see the user_guide."},{"objectID":"Home","href":"getting_started/index.html#api-eigen-example-c-project","title":"Getting started > API Eigen Example C++ project","text":"API Eigen Example C++ project"},{"objectID":"Home","href":"getting_started/index.html#installation","title":"Getting started > Installation","text":"Installation\n\nTo use the API Eigen Example C++ projects, the installation process is a bit more cumbersome.\nFirst install the packaged library cmake:\n\nDepending on the C++ project, dependencies vary. Go to your sections of interest from those that follow."},{"objectID":"Home","href":"getting_started/index.html#installation-of-the-c-rest-server","title":"Getting started > Installation of the C++ REST Server","text":"Installation of the C++ REST Server\n\nInstalling the C++ REST server manually is a simple process. Run the following commands from\nthe root of the repository:\n\nOnce dependencies are installed, you can use the C++ REST server. Start writing your own C++ main.cpp file and\ninclude the project header files as follows:\n\nFor compiling, link the library with:\n\nYou can run your server with:"},{"objectID":"Home","href":"getting_started/index.html#installation-of-the-c-rest-client","title":"Getting started > Installation of the C++ REST Client","text":"Installation of the C++ REST Client\n\nInstalling the C++ REST client manually is a bit more complex. You must install some\ndevelopment libraries and compile in place some additional external libraries.\n\nFirst, install a dev version of libcurl. Using the Ubuntu package manager apt, you can run:\n\nOnce libcurl-dev is installed, you must compile some external projects. These external projects have\nbeen frozen at a given version within this repository. You can find them in the external folder.\n\nTo install them, run these commands:\n\nOnce dependencies are installed, you can build and install the client library with:\n\nYou can use the REST C++ Client library. Start writing your own C++ client.cpp file and\ninclude the project header files as follows:\n\nFor compiling, link the library as follows:\n\nYou can run your client app with:"},{"objectID":"Home","href":"getting_started/index.html#installation-of-the-c-grpc-server","title":"Getting started > Installation of the C++ gRPC Server","text":"Installation of the C++ gRPC Server\n\nInstalling the C++ gRPC server manually is a simple process. To use the conan package manager\nto install dependencies, run the following command lines from the root of the repository:\n\nYou might need to run the previous install and deploy commands with root privileges.\n\nOnce dependencies are installed, you can use the C++ gRPC server. Start writing your own C++ main.cpp file and\ninclude the project header files as follows:\n\nFor compiling, link the library as follows:\n\nYou can run your server with:"},{"objectID":"Home","href":"getting_started/index.html#installation-of-the-c-grpc-client","title":"Getting started > Installation of the C++ gRPC Client","text":"Installation of the C++ gRPC Client\n\nInstalling the C++ gRPC client manually is a simple process. To use the conan\npackage manager to install dependencies, run the following commands from the root of the repository:\n\nYou might need to run the previous install and deploy commands with root privileges.\n\nOnce dependencies are installed, you can use the C++ gRPC client. Start writing your own C++ main.cpp file and\ninclude the project header files as follows:\n\nFor compiling, link the library as follows:\n\nYou can run your client with:"},{"objectID":"Home","href":"benchmark/index.html#benchmark-results","title":"Benchmark results","text":"Benchmark results\n\nOne of the tasks of this project is to evaluate the performance of different implementations, including using REST versus gRPC\nand the impact of the language used. This page displays the latest benchmark test results uploaded to the repository.\n\nSubsequent sections categorize these test results according to their implementation language. All sections have the this set of\ntests for both protocols:\n\nAdding two vectors of multiple sizes\n\nPerforming a dot product of two vectors of multiple sizes\n\nAdding two square matrices of multiple sizes\n\nMultiplying two matrices of multiple sizes\n\nGraphs show the parametrized sizes for these benchmark tests. The graphs are basically a sequence of powers of 2 (that is,\n2, 4, 8, 16, and so on). The final value is currently set to 2048, but it is easily adaptable."},{"objectID":"Home","href":"benchmark/index.html#benchmark-test-results","title":"Benchmark results > Benchmark test results","text":"Benchmark test results"},{"objectID":"Home","href":"benchmark/index.html#layout","title":"Benchmark results > Layout","text":"Layout\n\nThe layout of all figures show results for benchmark tests parametrized as:\n\nLanguage implementation: Python, C++\n\nAPI Protocol: REST, gRPC\n\nNumber of elements in data structures (that is, size of vector, matrix)"},{"objectID":"Home","href":"benchmark/index.html#adding-vectors","title":"Benchmark results > Adding vectors","text":"Adding vectors"},{"objectID":"Home","href":"benchmark/index.html#multiplying-vectors","title":"Benchmark results > Multiplying vectors","text":"Multiplying vectors"},{"objectID":"Home","href":"benchmark/index.html#adding-matrices","title":"Benchmark results > Adding matrices","text":"Adding matrices"},{"objectID":"Home","href":"benchmark/index.html#multiplying-matrices","title":"Benchmark results > Multiplying matrices","text":"Multiplying matrices"},{"objectID":"Home","href":"api/python-rest/restdb.html#python-rest-database-module","title":"Python REST database module","text":"Python REST database module\n\n\n\nPython implementation of the REST API Eigen example database.\n\n\n\nansys.eigen.python.rest.restdb.db.get_db()\n\nGet the database instance of the Flask app.\n\nReturns\n\nConnection\n\nConnection to the app’s database.\n\n\n\nansys.eigen.python.rest.restdb.db.init_app_db(app)\n\nInitialize a simple database for storing API REST data."},{"objectID":"Contributing","href":"contributing.html#contributing","title":"Contributing","text":"Contributing\n\nOverall guidance on contributing to a PyAnsys library appears in the\nContributing topic\nin the PyAnsys Developer’s Guide. Ensure that you are thoroughly familiar with\nit and all Guidelines and Best Practices before attempting to\ncontribute to the API Eigen Example repository.\n\nThe following contribution information is specific to the API Eigen Example repository."},{"objectID":"Contributing","href":"contributing.html#cloning-the-api-eigen-example-repository","title":"Contributing > Cloning the API Eigen Example Repository","text":"Cloning the API Eigen Example Repository\n\nRun this code to clone and install the latest version of the repository in development\nmode:"},{"objectID":"Contributing","href":"contributing.html#building-documentation","title":"Contributing > Building documentation","text":"Building documentation\n\nTo build the documentation locally you need to follow these steps at the root\ndirectory of the repository:\n\nAfter the build completes, the HTML documentation is located in the\n_builds/html directory. You can load the index.html into a web\nbrowser. To clear the documentation directory, you can run:"},{"objectID":"Contributing","href":"contributing.html#posting-issues","title":"Contributing > Posting issues","text":"Posting issues\n\nUse the API Eigen Example Issues page to\nsubmit questions, report bugs, and request new features."},{"objectID":"Contributing","href":"contributing.html#code-style","title":"Contributing > Code style","text":"Code style\n\nAPI Eigen Examples is compliant with the PyAnsys Development Code Style Guide.  Code style is checked\nby making use of pre-commit. Install this tool and\nactivate it with:\n\nThen, you can make use of the available configuration file .pre-commit-config.yml,\nwhich is automatically detected by pre-commit:"},{"objectID":"Home","href":"api/index.html#api-reference","title":"API reference","text":"API reference\n\nThis section describes the different API modules at a high level.\n\n\n\n"},{"objectID":"Home","href":"examples/sg_execution_times.html#computation-times","title":"Computation times","text":"Computation times\n\n00:00.000 total execution time for 0 files from examples:\n\n\n\n\n\n\n\nExample\n\nTime\n\nMem (MB)\n\nN/A\n\nN/A\n\nN/A"},{"objectID":"Home","href":"examples/00-rest-examples/sg_execution_times.html#computation-times","title":"Computation times","text":"Computation times\n\n00:00.067 total execution time for 1 file from examples/00-rest-examples:\n\n\n\n\n\n\n\nExample\n\nTime\n\nMem (MB)\n\nsphx_glr_examples_00-rest-examples_python_rest_demo.py (python_rest_demo.py)\n\n00:00.067\n\n0.0"},{"objectID":"Home","href":"api/cpp-rest/restdb.html#c-rest-database-module","title":"C++ REST database module","text":"C++ REST database module\n\n\n\nnamespace db\n\nNamespace including the API Eigen Example Server REST DB functionalities. \n\nEnums\n\n\n\nenum class DbTypes\n\nEnum holding the types of variables handled. \n\nValues:\n\n\n\nenumerator VECTOR\n\nThe Vector type. \n\n\n\nenumerator MATRIX\n\nThe Matrix type. \n\nFunctions\n\n\n\nstd::string dbtype_to_str(const DbTypes &value)\n\nMethod for returning the enum value as a std::string. \n\nParameters\n\nvalue – the enum value we want as a std::string. \n\nReturns\n\nstd::string \n\n\n\nstatic int callback(void *value, int argc, char **argv, char **azColName)\n\nCallback to be executed after function is complete. \n\nParameters\n\nvalue – pointer to the argument passed in sqlite3_exec. \n\nargc – number of callbacks to process. \n\nargv – values in each callback. \n\nazColName – name of the cols in the callback. \n\nReturns\n\nint \n\n\n\nclass RestDb\n\nClass for establishing a connection with the REST DB and interacting with it. \n\nPublic Functions\n\n\n\nRestDb()\n\nConstruct a new Rest Db object. \n\n\n\n~RestDb()\n\nDestroy the Rest Db object. \n\n\n\nlong store_resource(const DbTypes &type, const std::string &input)\n\nMethod for storing a Resource in the REST DB. \n\nParameters\n\ntype – the type of resource processed. \n\ninput – the JSON request body from where the resource is parsed. \n\nReturns\n\nlong - the id of the inserted row in the DB. \n\n\n\nstd::string load_resource(const DbTypes &type, const int &input)\n\nMethod in charge of loading a stored resource in the DB from a given ID. \n\nParameters\n\ntype – the type of resource processed. \n\ninput – the id of the resource inside the DB. \n\nReturns\n\nstd::string - the resource loaded from the DB (as a string). \n\nPrivate Functions\n\n\n\nvoid initialize_db()\n\nMethod for initializing the REST DB to be used. \n\nPrivate Members\n\n\n\nsqlite3 *_db\n\nA pointer to the DB connection. "},{"objectID":"Home","href":"api/cpp-rest/eigen.html#c-rest-eigen-binder-module","title":"C++ REST Eigen-binder module","text":"C++ REST Eigen-binder module\n\n\n\nnamespace eigen\n\nNamespace exposing functionalities of interest from the Eigen library for the API Eigen Example project. \n\nFunctions\n\n\n\nEigen::MatrixXd multiply_matrices(const Eigen::MatrixXd &a, const Eigen::MatrixXd &b)\n\nWrapper method to Matrix multiplication carried out by Eigen operators. \n\nParameters\n\na – The first matrix. \n\nb – The second matrix.\n\nReturns\n\nEigen::MatrixXd \n\n\n\nEigen::MatrixXd add_matrices(const Eigen::MatrixXd &a, const Eigen::MatrixXd &b)\n\nWrapper method to Matrix addition carried out by Eigen operators. \n\nParameters\n\na – The first matrix. \n\nb – The second matrix.\n\nReturns\n\nEigen::MatrixXd \n\n\n\ndouble multiply_vectors(const Eigen::VectorXd &v, const Eigen::VectorXd &w)\n\nWrapper method to Vector multiplication (dot product) carried out by Eigen operators. \n\nParameters\n\nv – The first vector. \n\nw – The second vector.\n\nReturns\n\ndouble \n\n\n\nEigen::VectorXd add_vectors(const Eigen::VectorXd &v, const Eigen::VectorXd &w)\n\nWrapper method to Vector addition carried out by Eigen operators. \n\nParameters\n\nv – The first vector. \n\nw – The second vector.\n\nReturns\n\nEigen::VectorXd \n\n\n\nEigen::VectorXd read_vector(const std::string &input)\n\nMethod in charge of parsing the JSON list to a vector. \n\nParameters\n\ninput – the JSON list. \n\nReturns\n\nEigen::VectorXd \n\n\n\nEigen::MatrixXd read_matrix(const std::string &input)\n\nMethod in charge of parsing the JSON list of lists to a matrix. \n\nParameters\n\ninput – the JSON list of lists. \n\nReturns\n\nEigen::MatrixXd \n\n\n\nstd::string write_vector(const Eigen::VectorXd &input)\n\nMethod in charge of writing a JSON list from the Eigen::VectorXd object given. \n\nParameters\n\ninput – the Eigen::VectorXd. \n\nReturns\n\nstd::string - representing the Vector as a JSON list. \n\n\n\nstd::string write_matrix(const Eigen::MatrixXd &input)\n\nMethod in charge of writing a JSON list from the Eigen::MatrixXd object given. \n\nParameters\n\ninput – the Eigen::MatrixXd. \n\nReturns\n\nstd::string - representing the Matrix as a JSON list. "},{"objectID":"Home","href":"examples/index.html#examples","title":"Examples","text":"Examples\n\nAdd examples here for the API Eigen Examples project.\n\n"},{"objectID":"Home","href":"examples/index.html#api-eigen-example---rest-demo","title":"Examples > API Eigen Example - REST Demo","text":"API Eigen Example - REST Demo\n\nThese examples demonstrate full examples of API REST interaction between a server and a client.\n\nsphx_glr_examples_00-rest-examples_python_rest_demo.py"},{"objectID":"Home","href":"examples/index.html#api-eigen-example---grpc-demo","title":"Examples > API Eigen Example - gRPC Demo","text":"API Eigen Example - gRPC Demo\n\nThese examples demonstrate full examples of API gRPC interaction between a server and a client.\n\nsphx_glr_examples_01-grpc-examples_python_grpc_demo.py\n\n\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"api/cpp-rest/client.html#c-rest-client-module","title":"C++ REST client module","text":"C++ REST client module\n\n\n\nnamespace client\n\nNamespace including the API Eigen Example Client implemented in C++. \n\nFunctions\n\n\n\nvoid print_response(const RestClient::Response &response)\n\nMethod for printing out Response objects in a common format. \n\nParameters\n\nresponse – the RestClient::Response object. \n\n\n\nclass EigenClient\n\nClass containing the basic functionalities to interact with the API Eigen Example server. \n\nPublic Functions\n\n\n\nEigenClient(const std::string &baseUrl, const std::string &user = std::string{}, const std::string &pwd = std::string{}, const int timeout = 10, const bool debug_log = false)\n\nConstruct a new Eigen Client object. \n\nParameters\n\nbaseUrl – the API Eigen Example server endpoint (e.g. http://127.0.0.1:18080). \n\nuser – (optional) the user in case of BasicAuthentication mechanism required. Default: empty. \n\npwd – (optional) the password in case of BasicAuthentication mechanism required. Default: empty. \n\ntimeout – (optional) the timeout to be set for aborting connection. Default: 10. \n\ndebug_log – whether to show the enhanced debugging logs or not. Default: false. \n\n\n\n~EigenClient()\n\nDestroy the Eigen Client object. \n\n\n\nvoid request_greeting()\n\nMethod to request a greeting from the endpoint server. \n\n\n\nstd::vector<double> add_vectors(const std::vector<double> &vec1, const std::vector<double> &vec2)\n\nMethod in charge of requesting a vector addition to the endpoint server. \n\nParameters\n\nvec1 – the first vector involved in the operation. \n\nvec2 – the second vector involved in the operation. \n\nReturns\n\nstd::vector<double> \n\n\n\ndouble multiply_vectors(const std::vector<double> &vec1, const std::vector<double> &vec2)\n\nMethod in charge of requesting a vector dot product to the endpoint server. \n\nParameters\n\nvec1 – the first vector involved in the operation. \n\nvec2 – the second vector involved in the operation. \n\nReturns\n\ndouble \n\n\n\nstd::vector<std::vector<double>> add_matrices(const std::vector<std::vector<double>> &mat1, const std::vector<std::vector<double>> &mat2)\n\nMethod in charge of requesting a matrix addition to the endpoint server. \n\nParameters\n\nmat1 – the first matrix involved in the operation. \n\nmat2 – the second matrix involved in the operation. \n\nReturns\n\nstd::vector<std::vector<double>> \n\n\n\nstd::vector<std::vector<double>> multiply_matrices(const std::vector<std::vector<double>> &mat1, const std::vector<std::vector<double>> &mat2)\n\nMethod in charge of requesting a matrix multiplication to the endpoint server. \n\nParameters\n\nmat1 – the first matrix involved in the operation. \n\nmat2 – the second matrix involved in the operation. \n\nReturns\n\nstd::vector<std::vector<double>> \n\nPrivate Functions\n\n\n\nint post_vector(const std::vector<double> &input)\n\nMethod in charge of connecting to the endpoint server to POST a Vector Resource. \n\nParameters\n\ninput – the vector we are interested in posting. \n\nReturns\n\nint - the ID of the posted vector. \n\n\n\nint post_matrix(const std::vector<std::vector<double>> &input)\n\nMethod in charge of connecting to the endpoint server to POST a Matrix Resource. \n\nParameters\n\ninput – the matrix we are interested in posting. \n\nReturns\n\nint - the ID of the posted matrix. \n\n\n\nJson::Value vector_to_json(const std::vector<double> &input)\n\nMethod in charge of transforming a std::vector of type double to a JSON object. \n\nParameters\n\ninput – the vector to be formatted as a JSON object. \n\nReturns\n\nJson::Value \n\n\n\nJson::Value matrix_to_json(const std::vector<std::vector<double>> &input)\n\nMethod in charge of transforming a std::vector<std::vecto> of type double to a JSON object. \n\nParameters\n\ninput – the matrix to be formatted as a JSON object. \n\nReturns\n\nJson::Value \n\n\n\nstd::vector<double> json_to_vector(const Json::Value &input)\n\nMethod in charge of transforming a JSON object which represents a vector into a std::vector<double>. \n\nParameters\n\ninput – the JSON object to be formatted as a vector. \n\nReturns\n\nstd::vector<double> \n\n\n\nstd::vector<std::vector<double>> json_to_matrix(const Json::Value &input)\n\nMethod in charge of transforming a JSON object which represents a matrix into a std::vector<std::vector<double>>. \n\nParameters\n\ninput – the JSON object to be formatted as a matrix. \n\nReturns\n\nstd::vector<std::vector<double>> \n\nPrivate Members\n\n\n\nRestClient::Connection *_conn = {nullptr}\n\nThe connection pointer to the endpoint server. \n\n\n\nbool _debug_log\n\nBoolean indicating whether to show the debugging logs or not. "},{"objectID":"Home","href":"api/cpp-grpc/server.html#c-rest-server-module","title":"C++ REST server module","text":"C++ REST server module\n\n\n\nnamespace server\n\nNamespace including the API Eigen Example Server implemented in C++. \n\n\n\nclass GRPCServer\n\nClass for deploying the API Eigen Example Server via its serve() method. \n\nPublic Functions\n\n\n\nGRPCServer()\n\nConstruct a new GRPCServer object. \n\n\n\n~GRPCServer()\n\nDestroy the GRPCServer object. \n\n\n\nvoid serve(const std::string host = std::string{\"0.0.0.0\"}, const int port = 50000, const bool debug_log = false)\n\nMethod for serving our application. \n\nParameters\n\nhost – the host (DNS/IP) in which we want to server our app. Default: 0.0.0.0. \n\nport – the port in which we want to server our app. Default: 50000. \n\ndebug_log – whether to show the enhanced debugging logs or not. \n\nPrivate Members\n\n\n\nstd::unique_ptr<::grpc::Server> _server\n\nPointer to the server instance. Required for shutting down when cancelled. "},{"objectID":"Home","href":"api/python-grpc/client.html#python-grpc-client-module","title":"Python gRPC client module","text":"Python gRPC client module\n\n\n\nPython implementation of the gRPC API Eigen Example client.\n\n\n\nclass ansys.eigen.python.grpc.client.DemoGRPCClient(ip='127.0.0.1', port=50051, timeout=1, test=None)\n\nBases: object\n\nProvides the API Eigen Example client class for interacting via gRPC.\n\n\n\nadd_matrices(*args)\n\nAdd numpy.ndarray matrices using the Eigen library on the server side.\n\nReturns\n\nnumpy.ndarray\n\nResulting numpy.ndarray of the matrices addition.\n\n\n\nadd_vectors(*args)\n\nAdd numpy.ndarray vectors using the Eigen library on the server side.\n\nReturns\n\nnumpy.ndarray\n\nResult of the given numpy.ndarrays.\n\n\n\nflip_vector(vector)\n\nFlip the position of a numpy.ndarray vector such that [A, B, C, D] –> [D, C, B, A].\n\nParameters\n\nvector\n\nnumpy.ndarray\n\nVector to flip.\n\nReturns\n\nnumpy.ndarray\n\nFlipped vector.\n\n\n\nmultiply_matrices(*args)\n\nMultiply numpy.ndarray matrices using the Eigen library on the server side.\n\nReturns\n\nnumpy.ndarray\n\nResulting numpy.ndarray of the matrices’ multiplication.\n\n\n\nmultiply_vectors(*args)\n\nMultiply numpy.ndarray vectors using the Eigen library on the server side.\n\nReturns\n\nnumpy.ndarray\n\nResult of the multiplication of numpy.ndarray vectors. Despite returning a numpy.ndarray, the result only contains one value because it is a dot product.\n\n\n\nrequest_greeting(name)\n\nMethod that requests a greeting from the server.\n\nParameters\n\nname\n\npython:str\n\nName of the “client”. For example, “Michael”."},{"objectID":"Home","href":"api/python-rest/client.html#python-rest-client-module","title":"Python REST client module","text":"Python REST client module\n\n\n\nPython implementation of the REST API Eigen example client.\n\n\n\nclass ansys.eigen.python.rest.client.DemoRESTClient(host, port, user=None, pwd=None, client=None)\n\nBases: object\n\nActs as a client to the service provided by the API REST server of this same project.\nThis class has several public methods that allow for direct interaction with the server,\nwithout having to care about the formatting of the RESTful queries.\n\n\n\nadd(arg1, arg2)\n\nAdd two numpy.ndarrays using the Eigen library (C++), which is exposed via the destination RESTful server.\n\nParameters\n\narg1\n\nnumpy.ndarray\n\nFirst numpy.ndarray to consider in the operation.\n\narg2\n\nnumpy.ndarray\n\nSecond numpy.ndarray to consider in the operation.\n\nReturns\n\nnumpy.ndarray\n\nSum of adding arg1 and arg2 (arg1 + arg2).\n\n\n\nget_connection_details()\n\nGet a simple summary of the connection details.\n\n\n\nmultiply(arg1, arg2)\n\nMultiply two numpy.ndarrays using the Eigen library (C++), which is exposed via the destination RESTful server.\n\nParameters\n\narg1\n\nnumpy.ndarray\n\nFirst numpy.ndarray to consider in the operation.\n\narg2\n\nnumpy.ndarray\n\nSecond numpy.ndarray to consider in the operation.\n\nReturns\n\nnumpy.ndarray\n\nThe result of multiplyng arg1 and arg2 (arg1 * arg2).\n\n\n\nsubtract(arg1, arg2)\n\nSubtract two numpy.ndarrays using the Eigen library\n(C++), which is exposed via the destination RESTful server.\n\nParameters\n\narg1\n\nnumpy.ndarray\n\nFirst numpy.ndarray to consider in the operation.\n\narg2\n\nnumpy.ndarray\n\nSecond numpy.ndarray to consider in the operation.\n\nReturns\n\nnumpy.ndarray\n\nThe result of subtracting arg2 from arg1 (arg1 - arg2)."},{"objectID":"Home","href":"api/cpp-rest/index.html#c-rest-subpackage","title":"C++ REST subpackage","text":"C++ REST subpackage\n\nThe C++ REST subpackage contains the needed elements for client-server interaction using REST.\n\n"},{"objectID":"Home","href":"examples/00-rest-examples/python_rest_demo.html#api-eigen-example---rest-demo-using-python","title":"API Eigen Example - REST Demo using Python","text":"API Eigen Example - REST Demo using Python\n\nThis demo shows how you can use the Python REST client of the API Eigen Example\nproject to communicate with the REST server. It uses a simple Python library to\nshow the basics of API REST protocols. This library contains two elements:\n\nA server that implements an API REST interface to communicate with an installed library within\n\nit, which is the Eigen library. This API REST interface exposes functionalities such as\nadding, subtracting and multiplying Eigen::VectorXd and Eigen::MatrixXd in a simple way.\n\nA client in charge of easing the interaction with the server by means of API REST-specific methods.\n\nWhen using the client library, you do not need to know the specifics of the API REST interface.\n\nTo run this demo, you must deploy a server. When the docs are generated\n(via workflows), the server is deployed as a service to compile the example. However, if you\nare planning on running the example on your own, you must deploy it manually by running these commands\non a different Python terminal:\n\n>>> import ansys.eigen.python.rest.server as rest_server\n>>> app = rest_server.create_app()\n>>> app.run(\"127.0.0.1\", 5000)\n\nOnce the server is up and running, you can import your client:"},{"objectID":"Home","href":"examples/00-rest-examples/python_rest_demo.html#the-demorestclient","title":"API Eigen Example - REST Demo using Python > The DemoRESTClient","text":"The DemoRESTClient\n\nThe DemoRESTClient class handles the API REST interface with the server,\ntogether with the connection itself, the formatting of the request, and more. When\nconstructing the class, you must provide as inputs the host and port of the server. For this\ndemo, since the server is already deployed (either manually or as a service in a container),\nuse the following arguments:\n\nHost: http://127.0.0.1\n\nPort: 5000\n\nThe server is exposed by IP 127.0.0.1 and port 5000 as per defined in the Dockerfile of the server\n(or if deployed manually, as specified previously). Thus, the previous inputs should be provided.\n\nThe DemoRESTClient class also allows for basic authentication in case the server was to be protected.\nSee below how to provide the user and pwd in this example:\n\nThe DemoRESTClient also has a method for retrieving the connection details of the client:\n\nNow, perform a simple operation like adding two 1D numpy.ndarrays. Start by defining them:"},{"objectID":"Home","href":"examples/00-rest-examples/python_rest_demo.html#performing-rest-interaction","title":"API Eigen Example - REST Demo using Python > Performing REST interaction","text":"Performing REST interaction\n\nExplanations follow for the typical process of all interface methods (add(), subtract() and multiply()):\n\nThe client performs some sanity checks to confirm that the inputs provided are as expected. This demo has some limitations, such as only allowing 1D and 2D numpy.ndarrays of the float64 type. However, to interact directly with the server, you must take other considerations into account regarding the format of your requests, which is why a client library is used).\n\nOnce the client has checked that everything is fine, it posts available resources. Here is where the REST world starts:\n\nServers expose resources, also known as entities, which are well understood if we compare them to objects. For example, if we want to POST a RESOURCE we should basically:\n\nPOST to ${server-uri}/${resource} –> In the demo: http://127.0.0.1:5000/Vectors\n\nThe Demo server has two resources implemented: Matrices and Vectors. Hence, it can handle only 1D and 2D numpy.ndarrays.\n\nWhen POSTing a resource, the request body contains the resource’s information. For example, the request contains the 1D numpy.ndarray that you want to POST). This information is usually serialized into a JSON format. The expected keys must be known by the client and the server to allow a proper interfacing. In a real REST application, the server usually exposes its metadata, which is basically the schema or structure of the different entities implemented (such as their names and attributes). This way, you know how to interact with the server without knowing the specifics of the implementation.\n\nImagine if you were to use CURL commands. The POST request for your first vector would look something like this:\n\ncurl -X POST \"http://127.0.0.1:5000/Vectors\" -H \"Content-Type: application/json\" -d '{\"value\":[5, 23, 3, 4]}'\n\nIf the POST was successful, you would receive an HTTP response that contains in its body the ID of the posted resource:\n\n{\"vector\" : {\"id\" : 1235412 }}\n\nThe server contains a database (DB) in which the resources posted are stored and retrieved from.\n\nAfter POSTings are performed, you proceed to ask the server for a certain operation involving the resources submitted.\n\nServers can also admit operations. A typical standard for defining operation endpoints would be:\n\nGET to ${server-uri}/${operation}/${resource} –> In the demo: http://127.0.0.1:5000/add/Vectors\n\nThese GET requests also contain in their bodies the IDs of the involved resources:\n\nImagine if you were to use CURL commands. The GET request for adding two vectors would look something like this:\n\ncurl -X GET \"http://127.0.0.1:5000/add/Vectors\" -H \"Content-Type: application/json\" -d '{\"id1\":1, \"id2\":2}'\n\nThe server then interacts with the DB, retrieves the vectors, calls the Eigen library (via a dedicated wrapper using pybind11), performs the operation, and returns the result.\n\nThe client then receives a response containing the result of the operation:\n\n{\"vector-addition\" : {\"result\" : [2.0, 3.0, 5.0, 4.0] }}\n\nThe dedicated client implemented then parses this JSON string and transforms the resulting value into a numpy.ndarray.\n\nThis way, you call the client library with numpy.ndarrays and retrieve numpy.ndarrays without having to know the specifics of the interface.\n\nAs mentioned before, there are several other methods implemented:\n\nHere are some operations with 2D numpy.ndarrays (matrices)\n\nTotal running time of the script: (0 minutes 0.067 seconds)\n\n\n\nDownload Jupyter notebook: python_rest_demo.ipynb\n\nDownload Python source code: python_rest_demo.py\n\nDownload zipped: python_rest_demo.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"examples/01-grpc-examples/python_grpc_demo.html#api-eigen-example---grpc-demo-using-python","title":"API Eigen Example - gRPC Demo using Python","text":"API Eigen Example - gRPC Demo using Python\n\nThis tutorial shows how you can use the Python gRPC Client of the API Eigen Example\nproject to communicate with the gRPC Server.\n\nIn the following demo, we will be showing the basics of API gRPC protocol by means of a\nsimple library we have created. This library basically contains two elements in its Python version:\n\nA server which basically implements an API gRPC interface to communicate with an installed library within\n\nit, in our case the Eigen library. This API gRPC interface basically exposes certain functionalities such as\nadding, subtracting and multiplying Eigen::VectorXd and Eigen::MatrixXd in a simple way. By using Protobuf,\nwe have created certain messages which both the server and the client know how to encode and decode.\n\nA client in charge of easing the interaction with the server by means of API gRPC interface specific methods.\n\nIn order to run this demo, it is necessary to deploy a server. When the docs are generated\n(via workflows), the server is deployed as a service to compile the example. However, if you\nare planning on running the example on your own, it is necessary to deploy it manually. In order to\ndo so, please run this on a different Python terminal:\n\n>>> import ansys.eigen.python.grpc.server as grpc_server\n>>> import logging\n>>> logging.basicConfig()\n>>> grpc_server.serve()\n\nNow, once the server is up and running. Let us import our client!"},{"objectID":"Home","href":"examples/01-grpc-examples/python_grpc_demo.html#the-demogrpcclient","title":"API Eigen Example - gRPC Demo using Python > The DemoGRPCClient","text":"The DemoGRPCClient\n\nThis DemoGRPCClient class is basically the one which will handle the API gRPC interface with the server,\ntogether with the connection itself, the formatting of the request and so on. When constructing the class we\nmust provide as inputs the ip and the port of the server. For this demo we are running, since we\nalready deployed the server (either manually or as a container), we will provide the following arguments:\n\nIP(or DNS): 127.0.0.1\n\nPort: 50051\n\nThe server is exposed by IP 127.0.0.1 and port 50051 as per defined in the Dockerfile of the server and\nthe server itself. Thus, the previous inputs should be provided, although they are also the default values. Nonetheless,\nin the IP field we could also provide the DNS for the sake of showing that DNS values are also accepted. In this case,\nby inserting localhost the connection would also be established.\n\nThis DemoGRPCClient also has a method for verifying the connection to out client, which is a simple\nhandshake/greeting, when we provide our name:\n\nThis will let us verify that the connection to the server is adequate and communication is favorable."},{"objectID":"Home","href":"examples/01-grpc-examples/python_grpc_demo.html#performing-grpc-interaction","title":"API Eigen Example - gRPC Demo using Python > Performing gRPC interaction","text":"Performing gRPC interaction\n\nNow, we will call the client method add_vectors(...), and we will explain the typical process of all interface methods (add_XXXX(...) and multiply_XXXX(...)):\n\nThe client performs some sanity checks to confirm that the inputs provided are as expected. This Demo has some limitations such as: only 1D, 2D numpy.ndarrays are allowed; they must be of type float64. Direct interaction with the server (i.e. without a client) and using gRPC is out of the scope of this demo. Doing so could be considered as “impossible” since you would have to serialize your message on your own, following the standard defined in the proto files.\n\nThe client serializes the messages with the inputs provided using generator functions. Our end server is characterized for receiving streams of messages, which basically represent a list of messages. Each of these messages are serialized following the interface proposed by the proto files, thanks to the automatically generated source code by protobuf.\n\nFor example our Vector message is characterized for having the following structure:\n\nenum DataType {INTEGER = 0;DOUBLE = 1;}\n\nmessage Vector {DataType data_type = 1; int32 vector_size = 2; bytes vector_as_chunk = 3;}\n\nWhen the server receives the messages, it deserializes them and interprets each of the previous fields. Thus, it is easily converted into a numpy.ndarray of the adequate type. Then, the desired vectors to be added are passed to the Eigen library via our demo_eigen_wrapper for the resolution of the demanded operation.\n\nOnce the results of the operation are available, the server serializes the result and responds with the adequate message to the client.\n\nFor example, according to the proto file, our server receives a stream of Vector messages, and returns a single Vector message (which contains the result of the requested operation):\n\nrpc AddVectors(stream Vector) returns (Vector) {}\n\nThe client then receives the response, deserializes the message and returns the corresponding result to the end-user as numpy.ndarray. Thus, the entire process is like a black-box for the end-user, and does not require to understand what is happening behind the scenes, since the end-user is only interested in the end-result.\n\nLet us now call the method!\n\nAs mentioned before, there are several other methods implemented:\n\nLet us show as well operations with 2D numpy.ndarrays (i.e. Matrices)\n\nTotal running time of the script: (0 minutes 0.022 seconds)\n\n\n\nDownload Jupyter notebook: python_grpc_demo.ipynb\n\nDownload Python source code: python_grpc_demo.py\n\nDownload zipped: python_grpc_demo.zip\n\nGallery generated by Sphinx-Gallery"},{"objectID":"Home","href":"examples/01-grpc-examples/index.html#api-eigen-example---grpc-demo","title":"API Eigen Example - gRPC Demo","text":"API Eigen Example - gRPC Demo\n\nThese examples demonstrate full examples of API gRPC interaction between a server and a client.\n\nsphx_glr_examples_01-grpc-examples_python_grpc_demo.py\n\n"},{"objectID":"Home","href":"api/python-grpc/server.html#python-grpc-server-module","title":"Python gRPC server module","text":"Python gRPC server module\n\n\n\nPython implementation of the gRPC API Eigen example server.\n\n\n\nclass ansys.eigen.python.grpc.server.GRPCDemoServicer\n\nBases: GRPCDemoServicer\n\nProvides methods that implement functionality of the API Eigen Example server.\n\n\n\nAddMatrices(request_iterator, context)\n\nAdd matrices.\n\nParameters\n\nrequest_iterator\n\niterator\n\nIterator to the stream of matrix messages provided.\n\ncontext\n\ngrpc.ServicerContext\n\ngRPC-specific information.\n\nReturns\n\ngrpcdemo_pb2.Matrix\n\nMatrix message.\n\n\n\nAddVectors(request_iterator, context)\n\nAdd vectors.\n\nParameters\n\nrequest_iterator\n\niterator\n\nIterator to the stream of vector messages provided.\n\ncontext\n\ngrpc.ServicerContext\n\ngRPC-specific information.\n\nReturns\n\ngrpcdemo_pb2.Vector\n\nVector message.\n\n\n\nFlipVector(request_iterator, context)\n\nFlip a given vector.\n\nParameters\n\nrequest_iterator\n\niterator\n\nIterator to the stream of vector messages provided.\n\ncontext\n\ngrpc.ServicerContext\n\ngRPC-specific information.\n\nReturns\n\ngrpcdemo_pb2.Vector\n\nFlipped vector message.\n\n\n\nMultiplyMatrices(request_iterator, context)\n\nMultiply two matrices.\n\nParameters\n\nrequest_iterator\n\niterator\n\nIterator to the stream of Matrix messages provided.\n\ncontext\n\ngrpc.ServicerContext\n\ngRPC-specific information.\n\nReturns\n\ngrpcdemo_pb2.Matrix\n\nMatrix message.\n\n\n\nMultiplyVectors(request_iterator, context)\n\nMultiply two vectors.\n\nParameters\n\nrequest_iterator\n\niterator\n\nIterator to the stream of vector messages provided.\n\ncontext\n\ngrpc.ServicerContext\n\ngRPC-specific information.\n\nReturns\n\ngrpcdemo_pb2.Vector\n\nVector message.\n\n\n\nSayHello(request, context)\n\nTest the greeter method to see if the server is up and running correctly.\n\nParameters\n\nrequest\n\nHelloRequest\n\nGreeting request sent by the client.\n\ncontext\n\ngrpc.ServicerContext\n\ngRPC-specific information.\n\nReturns\n\ngrpcdemo_pb2.HelloReply\n\nReply to greeting by the server.\n\n\n\nansys.eigen.python.grpc.server.check_data_type(dtype, new_dtype)\n\nCheck if the new data type is the same as the previous data type.\n\nParameters\n\ndtype\n\nnumpy.type\n\nType of the numpy array before processing.\n\nnew_dtype\n\nnumpy.type\n\nType of the numpy array to be processed.\n\nReturns\n\nnumpy.type\n\nType of the numpy array.\n\nRaises\n\nRuntimeError\n\nIn case there is already a type and it does not match that of the new_type argument.\n\n\n\nansys.eigen.python.grpc.server.check_size(size, new_size)\n\nCheck if the new parsed size is the same as the previous size.\n\nParameters\n\nsize\n\npython:tuple\n\nSize of the numpy array before processing.\n\nnew_size\n\n_type_\n\nSize of the numpy array to process.\n\nReturns\n\npython:tuple\n\nSize of the numpy array.\n\nRaises\n\nRuntimeError\n\nIn case there is already a size and it does not match that of the new_size argument.\n\n\n\nansys.eigen.python.grpc.server.serve()\n\nDeploy the API Eigen Example server."},{"objectID":"Home","href":"docker/index.html#docker-examples","title":"Docker examples","text":"Docker examples\n\nAs part of the development of this project, several Docker images were created to allow\ndirect use of the client and server modules for both REST and gRPC using Python and C++.\nYou can refer to demo section of interest to you."},{"objectID":"Home","href":"docker/index.html#rest-api-using-python","title":"Docker examples > REST API using Python","text":"REST API using Python\n\nFor this demo, the following Docker containers are available:\n\npython-rest-client: Docker container with the needed packages for running the implemented client (from from ansys.eigen.python.rest.client import DemoRESTClient)\n\npython-rest-server: Docker container with the needed packages for running the server with the Eigen library solver\n\nThese Docker containers are available at the GitHub Container Registry. You can download the latest version with:\n\nHowever, you can also build these Docker containers manually from the root directory of the repository with:\n\nThe server Docker image is a standalone Flask app that starts whenever the image is run. This way,\nyou do not have to perform any other operation apart from running the Docker image.\n\nTo run the server Docker image manually, you must run:\n\nThe client Docker image is a standalone JupyterLab app that starts whenever the image is run. This JupyterLab\napp contains a demo Jupyter Notebook that you can run to test the client itself. Furthermore, you can open a new\nJupyter Notebook within JupyterLab and start creating your own app.\n\nTo run the client Docker image manually, you must run:\n\nHowever, deploying Docker containers manually is not the easiest way to test them. To start playing around with\nthem, you can use the docker-compose task at https://github.com/ansys/api-eigen-example/blob/main/docker/python-rest/docker-compose.yml.\nThis task simplifies the deployment of both Docker containers and eases the configuration characteristics of each of them\nbecause they are located in the same Docker network.\n\nTo launch the Docker compose task, simply run the following wherever the docker-compose.yml file is located:\n\nYou can then start playing around with the Docker compose demo."},{"objectID":"Home","href":"docker/index.html#grpc-api-using-python","title":"Docker examples > gRPC API using Python","text":"gRPC API using Python\n\nFor this demo, the following Docker containers are available:\n\npython-grpc-client: Docker container with the needed packages for running the implemented client (from ansys.eigen.python.grpc.client import DemoGRPCClient)\n\npython-grpc-server: Docker container with the needed packages for running the server with the Eigen library solver\n\nThese Docker containers are available at the GitHub Container Registry. You can download the latest version with:\n\nHowever, you can also build these Docker containers manually from the root directory of the repository with:\n\nThe server Docker image is a standalone gRPC server that starts whenever the image is run. This way,\nyou do not have to perform any other operation apart from running the Docker image.\n\nTo run the server Docker image manually, you must run:\n\nThe client Docker image is a standalone JupyterLab app that starts whenever the image is run. This JupyterLab\napp contains a demo Jupyter Notebook that you can run to test the client itself. Furthermore, you can open a new\nJupyter Notebook within the JupyterLab and start creating your own app.\n\nTo run the client Docker image manually, you must run:\n\nHowever, deploying Docker containers manually is not the easiest way to test them. To start playing around with\nthem, you can use the docker-compose task at https://github.com/ansys/api-eigen-example/blob/main/docker/python-grpc/docker-compose.yml.\nThis task simplifies the deployment of both Docker containers and eases the configuration characteristics of each of them\nbecause they are located in the same Docker network.\n\nTo launch the Docker compose task, simply run the following command wherever the docker-compose.yml file is located:\n\nYou can then start playing around with the Docker compose demo."},{"objectID":"Home","href":"docker/index.html#rest-api-using-c","title":"Docker examples > REST API using C++","text":"REST API using C++\n\nFor this demo, the following Docker containers are available:\n\ncpp-rest-client: Docker container with the needed packages for running the implemented client (#include <apieigen/rest/EigenClient.hpp>)\n\ncpp-rest-server: Docker container with the needed packages for running the server with the Eigen library solver\n\nThese Docker containers are available at the GitHub Container Registry. You can download the latest version with:\n\nHowever, you can also build these Docker containers manually from the root directory of the repository with:\n\nThe server Docker image is a standalone CrowCpp app that starts whenever the image is run. This way,\nyou do not have to perform any other operation apart from running the Docker image.\n\nTo run the server Docker image manually, you must run:\n\nThe client Docker image is a standalone JupyterLab app that starts whenever the image is run. This JupyterLab\napp contains a demo Jupyter Notebook that you can run to test the client itself. Furthermore, you can open a new\nJupyter Notebook within JupyterLab and start creating your own app.\n\nTo run the client Docker image manually, you must run:\n\nEven though dealing with a C++ implementation, thanks to cling and\nxeus-cling, this demo is capable of demonstrating\nvia Jupyter Notebooks the functionalities of the C++ client as if it were an interpretable language (like Python or Matlab).\nSpecial thanks to their contributors for these great packages.\n\nHowever, deploying Docker containers manually is not the easiest way to test them. To start playing around with\nthem, you can use the docker-compose task at https://github.com/ansys/api-eigen-example/blob/main/docker/cpp-rest/docker-compose.yml.\nThis task simplifies the deployment of both Docker containers and eases the configuration characteristics of each of them\nbecause they are be located in the same Docker network.\n\nTo launch the Docker compose task, simply run the following command where the docker-compose.yml file is located:\n\nYou can then start playing around with the Docker compose demo."},{"objectID":"Home","href":"docker/index.html#grpc-api-using-c","title":"Docker examples > gRPC API using C++","text":"gRPC API using C++\n\nFor this demo, the following Docker containers are available:\n\ncpp-grpc-client: Docker container with the needed packages for running the implemented client (#include <apieigen/grpc/GRPCClient.hpp>)\n\ncpp-grpc-server: Docker container with the needed packages for running the server with the Eigen library solver\n\nThese Docker containers are available at the GitHub Container Registry. You can download the latest version with:\n\nHowever, you can also build these Docker containers manually from the root directory of the repository with:\n\nThe server Docker image is a standalone gRPC app that starts whenever the image is run. This way,\nyou do not have to perform any other operation apart from running the Docker image.\n\nTo run the server Docker image manually, you must run:\n\nThe client Docker image is a standalone JupyterLab app that starts whenever the image is run. This JupyterLab\napp contains a demo Jupyter Notebook that you can run to test the client itself. Furthermore, you can open a new Jupyter\nNotebook within JupyterLab and start creating your own app.\n\nTo run the client Docker image manually, you must run:\n\nEven though dealing with a C++ implementation, thanks to cling and\nxeus-cling, this demo is capable of demonstrating\nvia Jupyter Notebooks the functionalities of the C++ client as if it were an interpretable language (like Python or Matlab).\nSpecial thanks to their contributors for these great packages.\n\nHowever, deploying the Docker containers manually is not the easiest way to test them. To start playing around with\nthem, you can use the docker-compose task at https://github.com/ansys/api-eigen-example/blob/main/docker/cpp-grpc/docker-compose.yml.\nThis task simplifies the deployment of both Docker containers and eases the configuration characteristics of each of them\nbecause they are located in the same Docker network.\n\nTo launch the Docker compose task, simply run the following command wherever the docker-compose.yml file is located:\n\nYou can then start playing around with the Docker compose demo."},{"objectID":"Home","href":"api/cpp-grpc/client.html#c-grpc-client-module","title":"C++ gRPC client module","text":"C++ gRPC client module\n\n\n\nnamespace client\n\nNamespace including the API Eigen Example Client implemented in C++. \n\n\n\nclass GRPCClient\n\nClass containing the basic functionalities to interact with the API Eigen Example server. \n\nPublic Functions\n\n\n\nGRPCClient(const std::string host = std::string{\"0.0.0.0\"}, const int port = 50000, const bool debug_log = false)\n\nConstruct a new GRPC Client object. \n\nParameters\n\nhost – the host (DNS/IP) where the server is located. Default: 0.0.0.0. \n\nport – the port through which the server is exposed. Default: 50000. \n\ndebug_log – whether to show the enhanced debugging logs or not. Default: false. \n\n\n\n~GRPCClient()\n\nDestroy the GRPC Client object. \n\n\n\nvoid request_greeting(const std::string &name)\n\nMethod to request a greeting from the endpoint server. \n\nParameters\n\nname – the name of the entity requesting the greeting (i.e. us). \n\n\n\nstd::vector<double> flip_vector(const std::vector<double> &vec)\n\nMethod in charge of requesting a vector position flip to the endpoint server. \n\nParameters\n\nvec – the first vector involved in the operation. \n\nReturns\n\nstd::vector<double> \n\n\n\nstd::vector<double> add_vectors(const std::vector<double> &vec1, const std::vector<double> &vec2)\n\nMethod in charge of requesting a vector addition to the endpoint server. \n\nParameters\n\nvec1 – the first vector involved in the operation. \n\nvec2 – the second vector involved in the operation. \n\nReturns\n\nstd::vector<double> \n\n\n\ndouble multiply_vectors(const std::vector<double> &vec1, const std::vector<double> &vec2)\n\nMethod in charge of requesting a vector dot product to the endpoint server. \n\nParameters\n\nvec1 – the first vector involved in the operation. \n\nvec2 – the second vector involved in the operation. \n\nReturns\n\ndouble \n\n\n\nstd::vector<std::vector<double>> add_matrices(const std::vector<std::vector<double>> &mat1, const std::vector<std::vector<double>> &mat2)\n\nMethod in charge of requesting a matrix addition to the endpoint server. \n\nParameters\n\nmat1 – the first matrix involved in the operation. \n\nmat2 – the second matrix involved in the operation. \n\nReturns\n\nstd::vector<std::vector<double>> \n\n\n\nstd::vector<std::vector<double>> multiply_matrices(const std::vector<std::vector<double>> &mat1, const std::vector<std::vector<double>> &mat2)\n\nMethod in charge of requesting a matrix multiplication to the endpoint server. \n\nParameters\n\nmat1 – the first matrix involved in the operation. \n\nmat2 – the second matrix involved in the operation. \n\nReturns\n\nstd::vector<std::vector<double>> \n\nPrivate Functions\n\n\n\nstd::vector<std::vector<int>> define_vecstream_metadata(::grpc::ClientContext *context, const std::vector<double> &vec1, const std::vector<double> &vec2 = {})\n\nMethod in charge of defining the Client Metadata in the bidirectional stream transfer of Vector messages. \n\nParameters\n\ncontext – the gRPC context. \n\nvec1 – the vector to be transmitted. \n\nvec2 – (optional) the second vector to be transmitted. \n\nReturns\n\nstd::vector<std::vector<int>> \n\n\n\nstd::vector<int> set_vector_metadata(::grpc::ClientContext *context, const std::vector<double> &vec, const std::string &vec_name)\n\nSet the Vector-specific message metadata (i.e. how many partial Vector messages constitute an entire Vector). \n\nParameters\n\ncontext – the gRPC context. \n\nvec – the vector to be transmitted. \n\nvec_name – the identifier of the vector. \n\nReturns\n\nstd::vector<int> \n\n\n\nstd::vector<std::vector<int>> define_matstream_metadata(::grpc::ClientContext *context, const std::vector<std::vector<double>> &mat1, const std::vector<std::vector<double>> &mat2)\n\nMethod in charge of defining the Client Metadata in the bidirectional stream transfer of Matrix messages. \n\nParameters\n\ncontext – the gRPC context. \n\nmat1 – the first matrix to be transmitted. \n\nmat2 – the second matrix to be transmitted. \n\nReturns\n\nstd::vector<std::vector<int>> \n\n\n\nstd::vector<int> set_matrix_metadata(::grpc::ClientContext *context, const std::vector<std::vector<double>> &mat, const std::string &mat_name)\n\nSet the Matrix-specific message metadata (i.e. how many partial Matrix messages constitute an entire Matrix). \n\nParameters\n\ncontext – the gRPC context. \n\nmat – the matrix to be transmitted. \n\nmat_name – the identifier of the matrix. \n\nReturns\n\nstd::vector<int> \n\n\n\nstd::vector<double> deserialize_vector(const std::string &bytes, const int length, grpcdemo::DataType type)\n\nMethod used to deserialize a Vector message into an std::vector<double> object. \n\nParameters\n\nbytes – the chunk of bytes from where the vector is deserialized. \n\nlength – the length of the vector we are deserializing. \n\ntype – the type of data inside the vector (e.g. double, int…). \n\nReturns\n\nstd::vector<double> \n\n\n\nstd::string serialize_vector(const std::vector<double> &vector, const int start, const int end)\n\nMethod used to serialize an std::vector<double> object into a Vector message. \n\nParameters\n\nvector – the std::vector<double> to be serialized. \n\nstart – the starting index to serialize. \n\nend – the last index to serialize (not included). \n\nReturns\n\nstd::string \n\n\n\nstd::vector<std::vector<double>> deserialize_matrix(const std::string &bytes, const int rows, const int cols, grpcdemo::DataType type)\n\nMethod used to deserialize a Matrix message into an std::vector<std::vector<double>> object. \n\nParameters\n\nbytes – the chunk of bytes from where the matrix is deserialized. \n\nrows – the number of rows of the matrix we are deserializing. \n\ncols – the number of columns of the matrix we are deserializing. \n\ntype – the type of data inside the matrix (e.g. double, int…). \n\nReturns\n\nstd::vector<std::vector<double>> \n\n\n\nstd::string serialize_matrix(const std::vector<std::vector<double>> &matrix, const int start, const int end)\n\nMethod used to serialize an std::vector<std::vector<double>> object into a Matrix message. \n\nParameters\n\nmatrix – the std::vector<std::vector<double>> to be serialized. \n\nstart – the starting row index to serialize. \n\nend – the last row index to serialize (not included). \n\nReturns\n\nstd::string \n\n\n\nvoid send_vector(std::unique_ptr<::grpc::ClientReaderWriter<grpcdemo::Vector, grpcdemo::Vector>> &reader_writer, const std::vector<double> &vector, const std::vector<int> &chunks)\n\nMethod in charge of sending a message for stream-based inputs in RPC method. Targeted to Vector messages. \n\nParameters\n\nreader_writer – the writer used for streaming the messages. \n\nvector – the message to be streamed. \n\nchunks – number of elements in each individual Vector message. \n\n\n\nvoid send_matrix(std::unique_ptr<::grpc::ClientReaderWriter<grpcdemo::Matrix, grpcdemo::Matrix>> &reader_writer, const std::vector<std::vector<double>> &matrix, const std::vector<int> &chunks)\n\nMethod in charge of sending a message for stream-based inputs in RPC method. Targeted to Matrix messages. \n\nParameters\n\nreader_writer – the writer used for streaming the messages. \n\nmatrix – the message to be streamed. \n\nchunks – number of elements in each individual Vector message. \n\n\n\nstd::vector<double> receive_vector(std::unique_ptr<::grpc::ClientReaderWriter<grpcdemo::Vector, grpcdemo::Vector>> &reader_writer, ::grpc::ClientContext *context)\n\nMethod in charge of providing the resulting Vector of an operation requested to the server from a stream of partial Vector messages. \n\nParameters\n\nreader_writer – the gRPC reader-writer in the bidirectional stream protocol. \n\ncontext – the gRPC context. \n\nReturns\n\nstd::vector<double> \n\n\n\nstd::vector<std::vector<double>> receive_matrix(std::unique_ptr<::grpc::ClientReaderWriter<grpcdemo::Matrix, grpcdemo::Matrix>> &reader_writer, ::grpc::ClientContext *context)\n\nMethod in charge of providing the resulting Matrix of an operation requested to the server from a stream of partial Matrix messages. \n\nParameters\n\nreader_writer – the gRPC reader-writer in the bidirectional stream protocol. \n\ncontext – the gRPC context. \n\nReturns\n\nstd::vector<std::vector<double>> \n\nPrivate Members\n\n\n\nstd::unique_ptr<grpcdemo::GRPCDemo::Stub> _stub\n\nA unique pointer to the stub which defines the gRPC connection (Channel). \n\n\n\nbool _debug_log\n\nBoolean indicating whether to show the debugging logs or not. "}]