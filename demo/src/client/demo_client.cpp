/*
 *
 * Copyright 2015 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <iostream>
#include <memory>
#include <string>

#include <grpcpp/grpcpp.h>

// autogenerated
#include "chunkdemo.grpc.pb.h"

#define DEFAULT_CHUNKSIZE 256*1024  // 256 kBps

using namespace std::chrono;

using grpc::Channel;
using grpc::ClientContext;
using grpc::Status;

using chunkdemo::Chunk;
using chunkdemo::StreamRequest;
using chunkdemo::DataType;
using chunkdemo::ChunkDemo;
using chunkdemo::PopulateArrayRequest;
using chunkdemo::Empty;
using std::endl;

// Format a quantity in bytes into a human readable string
// Credit goes to https://gist.github.com/dgoguerra/7194777
static const char *humanSize(uint64_t bytes){
  const char *suffix[] = {"B", "KB", "MB", "GB", "TB"};
  char length = sizeof(suffix) / sizeof(suffix[0]);

  int i = 0;
  double dblBytes = bytes;

  if (bytes > 1024) {
    for (i = 0; (bytes / 1024) > 0 && i<length-1; i++, bytes /= 1024)
      dblBytes = bytes / 1024.0;
  }

  static char output[200];
  sprintf(output, "%.02lf %s", dblBytes, suffix[i]);
  return output;
}


// For converting from strings
void StrToVal(std::string strVal, int &ival) { ival = std::stoi( strVal);}
void StrToVal(std::string strVal, double &dval) { dval = std::stof( strVal);}
void StrToVal(std::string strVal, std::string &sval) { sval = strVal;}

template <typename T> T
GetInitialMetadataValue(ClientContext* context, std::string name, T DefaultValue){
  T Val = DefaultValue;
  auto mapMetaData = context->GetServerInitialMetadata();
  auto iterMetaData = mapMetaData.find( name);

  if (iterMetaData != mapMetaData.end()){
    std::string	strVal = iterMetaData->second.data();
    StrToVal( strVal, Val);
  }

  return Val;
}

template int GetInitialMetadataValue<int>(ClientContext* context, std::string name,
					  int DefaultValue);
template double GetInitialMetadataValue<double>(ClientContext* context,
						std::string name, double DefaultValue);


class DemoClient {
 public:
  DemoClient(std::shared_ptr<Channel> channel)
      : stub_(ChunkDemo::NewStub(channel)) {}

  // Request the server create an array of int of size `array_size`
  void PopulateArray(int array_size){

    // assemmble the request
    PopulateArrayRequest request;
    request.set_array_size(array_size);

    // send the RPC
    Empty reply;
    ClientContext context;
    Status status = stub_->PopulateArray(&context, request, &reply);

    // Act on the status
    // if (status.ok()) {
    //   std::cout << "Array Created" << endl;
    // } else {
    //   std::cout << "Failed to create array" << endl;
    // }

    return;
  }

  // stream back an array using byte chunks
  void RequestArray(int chunk_size=DEFAULT_CHUNKSIZE){

    // assemmble the request and send the RPC
    StreamRequest request;
    ClientContext context;
    context.AddMetadata("chunk_size", std::to_string(chunk_size));
    std::unique_ptr<grpc::ClientReader<Chunk>> reader(stub_->DownloadArray(&context, request));

    // size the array
    reader->WaitForInitialMetadata();
    const int array_size = GetInitialMetadataValue<int>(&context, "size", 0);
    int *array = new int[array_size];
    char *rawarray = (char*)array;

    // Read data from the server in chunks
    Chunk chunk;
    while (reader->Read(&chunk)) {
	const std::string payload = chunk.payload();

	// *Probably* slower:
	// for (unsigned int i=0; i<payload.size(); i++) {
	//   rawarray[i] = payload[i];
	// }

	memcpy(rawarray, payload.c_str(), payload.size());
	rawarray += payload.size();
    }
  }


  // stream back an array using repeated messages
  void RequestArrayFromRepeated(){

    // assemmble the request and send the RPC
    StreamRequest request; // should use empty request
    ClientContext context;
    chunkdemo::RepeatedInts reply;
    Status status = stub_->DownloadArraySlow(&context, request, &reply);

    std::vector<int> res_vec(reply.ints().begin(), reply.ints().end());
  }

  // stream back an array using repeated messages
  void RequestArrayFromRepeatedChunked() {

      // assemble the request and send the RPC
      StreamRequest request; // should use empty request
      ClientContext context;
      std::unique_ptr<grpc::ClientReader<chunkdemo::RepeatedInts>> reader(stub_->DownloadArrayChunkedRepeated(&context, request));
      chunkdemo::RepeatedInts chunk;
      std::vector<int> res_vec;
      while(reader->Read(&chunk)) {
        res_vec.insert(res_vec.end(), chunk.ints().begin(), chunk.ints().end());
      }
  }

 private:
  std::unique_ptr<ChunkDemo::Stub> stub_;
};


// returns a command line option
char* getCmdOption(char ** begin, char ** end, const std::string & option){
    char ** itr = std::find(begin, end, option);
    if (itr != end && ++itr != end)
    {
        return *itr;
    }
    return 0;
}


// True when command line option exists
bool cmdOptionExists(char** begin, char** end, const std::string& option){
    return std::find(begin, end, option) != end;
}

int main(int argc, char** argv) {
  // Instantiate the client. It requires a channel, out of which the actual RPCs
  // are created. This channel models a connection to an endpoint (in this case,
  // localhost at port 50050). We indicate that the channel isn't authenticated
  // (use of InsecureChannelCredentials()).

  std::string target_str;

  if (cmdOptionExists(argv, argv + argc, "-h")){
    std::cout << "demo_client [options]" << endl <<
      "Options:" << endl <<
      "-h               Print this help" << endl <<
      "--target         Set the target channel (default localhost:50000)" << endl <<
      "--chunk_size     Set the chunk size in kB (default 256)" << endl <<
      "--skip_repeated  Skip testing the repeated messages" << endl <<
      "--array_size     Size of array in int32" << endl <<
      "--ntimes_stream  Number of times to test the stream" << endl;
    return 0;
  }


  // Configure target channel
  if (cmdOptionExists(argv, argv + argc, "--target")){
    target_str = getCmdOption(argv, argv + argc, "--target");
  } else {
    target_str = "localhost:50000";
  }

  int chunk_size;
  if (cmdOptionExists(argv, argv + argc, "--chunk_size")){
    chunk_size = std::stoi(getCmdOption(argv, argv + argc, "--chunk_size")) * 1024;
  } else {
    chunk_size = DEFAULT_CHUNKSIZE;
  }

  grpc::ChannelArguments args;
  args.SetMaxReceiveMessageSize(-1);
  // create client
  DemoClient client(grpc::CreateCustomChannel(
      target_str, grpc::InsecureChannelCredentials(), args));
  std::cout << "Connected to server at: " << target_str << endl;


  // Start by initializing the array on the server
  int array_size;
  if (cmdOptionExists(argv, argv + argc, "--array_size")){
    array_size = std::stoi(getCmdOption(argv, argv + argc, "--array_size"));
  } else {
    array_size = 10000000;
  }

  client.PopulateArray(array_size);
  std::cout << "Created an INT32 array on the server size " << array_size << endl;
  std::cout << "Array is " << humanSize(array_size*sizeof(int)) << endl;
  std::cout << endl;

  //////////////// Test with byte stream ////////////////
  std::cout << "Testing with byte stream..." << endl;
  std::cout << "Using chunk size " << chunk_size/1024 << " kB" << endl;

  // Run a few times
  // Start by initializing the array on the server
  int ntimes;
  if (cmdOptionExists(argv, argv + argc, "--ntimes_stream")){
    ntimes = std::stoi(getCmdOption(argv, argv + argc, "--ntimes_stream"));
  } else {
    ntimes = 20;
  }
  auto start = high_resolution_clock::now();
  for (int i=0; i<ntimes; i++){
    client.RequestArray(chunk_size);
  }

  auto stop = high_resolution_clock::now();
  double duration = duration_cast<microseconds>(stop - start).count();
  duration /= 1000000;  // microseconds to seconds
  duration /= ntimes;
  std::cout << "Average time: " << duration << endl;

  double bps = array_size*sizeof(int)/duration; // bytes per second
  std::cout << "Approx speed: " << humanSize(bps) << "ps" << endl;
  std::cout << endl;


  //////////////// Test with repeated messages ////////////////
  if (cmdOptionExists(argv, argv + argc, "--skip_repeated")){
    return 0;
  }
  std::cout << "Testing with repeated messages..." << endl;

  // Start by initializing the array on the server
  // client.PopulateArray(array_size);

  // Run a few times
  ntimes = 3;
  start = high_resolution_clock::now();
  for (int i=0; i<ntimes; i++){
    client.RequestArrayFromRepeated();
  }

  stop = high_resolution_clock::now();
  duration = duration_cast<microseconds>(stop - start).count();
  duration /= 1000000;  // microseconds to seconds
  duration /= ntimes;
  std::cout << "Average time: " << duration << endl;

  bps = array_size*sizeof(int)/duration; // bytes per second
  std::cout << "Approx speed: " << humanSize(bps) << "ps" << endl;
  std::cout << endl;

  //////////////// Test with repeated chunked messages ////////////////
  // if (cmdOptionExists(argv, argv + argc, "--skip_repeated")) {
  //     return 0;
  // }
  std::cout << "Testing with repeated chunked messages..." << endl;

  // Start by initializing the array on the server
  // client.PopulateArray(array_size);

  // Run a few times
  ntimes = 3;
  start = high_resolution_clock::now();
  for (int i = 0; i < ntimes; i++) {
      client.RequestArrayFromRepeatedChunked();
  }

  stop = high_resolution_clock::now();
  duration = duration_cast<microseconds>(stop - start).count();
  duration /= 1000000; // microseconds to seconds
  duration /= ntimes;
  std::cout << "Average time: " << duration << endl;

  bps = array_size * sizeof(int) / duration; // bytes per second
  std::cout << "Approx speed: " << humanSize(bps) << "ps" << endl;
  std::cout << endl;

  return 0;
}
